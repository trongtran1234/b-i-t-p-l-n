module alu (ALUSel, ALUOut, Reg_1, Reg_2);


parameter CONTROL_WIDTH = 4;
parameter DATA_WIDTH    = 32;

input  [CONTROL_WIDTH-1:0] ALUSel;
input   [DATA_WIDTH-1:0]    Reg_1;
input   [DATA_WIDTH-1:0]    Reg_2;
output  [DATA_WIDTH-1:0]    ALUOut;
reg     [DATA_WIDTH-1:0]    ALUOut;
wire    [DATA_WIDTH-1:0]    shl_ALUOut;
wire    [DATA_WIDTH-1:0]    sum;
wire    [DATA_WIDTH-1:0]    diff;
wire    [DATA_WIDTH-1:0]    and_ALUOut;
wire    [DATA_WIDTH-1:0]    or_ALUOut;
wire    [DATA_WIDTH-1:0]    xor_ALUOut;
wire    [DATA_WIDTH-1:0]    shr_ALUOut;
wire    [DATA_WIDTH-1:0]    less_than;
wire    [DATA_WIDTH-1:0]    greater_than;
wire                        sign;


assign sum          = Reg_1 + Reg_2;
assign diff         = Reg_1 - Reg_2;
assign and_ALUOut   = Reg_1 & Reg_2;
assign or_ALUOut    = Reg_1 | Reg_2;
assign xor_ALUOut   = Reg_1 ^ Reg_2;
assign less_than    = Reg_1 < Reg_2;
assign greater_than = Reg_1 > Reg_2;
assign shl_ALUOut   = Reg_1 << Reg_2[4:0];
assign sign         = Reg_1[31] & (ALUSel == 7);
assign shr_ALUOut   = { {32{sign}}, Reg_1 } >> Reg_2[4:0];


always @ (*) begin
   case (ALUSel)
      4'b0000: ALUOut = sum;                // Add
      4'b1000: ALUOut = diff;               // Subtract
      4'b0111: ALUOut = and_ALUOut;         // And
      4'b0110: ALUOut = or_ALUOut;          // Or
      4'b0100: ALUOut = xor_ALUOut;         // Xor
      4'b0001: ALUOut = shl_ALUOut;         // SHL
      4'b0101: ALUOut = shr_ALUOut;         // SHR
      4'b0101: ALUOut = shr_ALUOut;         // SHRA
      4'b0010: ALUOut = less_than;          // less than
      4'b1101: ALUOut = greater_than;       // greater than
      4'b1111: ALUOut = Reg_2;
      default: ALUOut = Reg_1;              // through
   endcase
end
endmodule
